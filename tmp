INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/util/upgrade_proto.cpp:77] Attempting to upgrade batch norm layers using deprecated params: ./examples/style_transfer/style.prototxt
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/util/upgrade_proto.cpp:80] Successfully upgraded batch norm layers using deprecated params.
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer data
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] data -> data
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] conv1 -> conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 786432
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 8388608
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 512
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 512
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 512
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 512
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 262144
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 262144
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 9
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 9
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 4
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 4
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 3
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 32
#ifdef MG
#undef MG
#endif
#define MG 32
#ifdef M
#undef M
#endif
#define M 32
#ifdef N
#undef N
#endif
#define N 262144
#ifdef KG
#undef KG
#endif
#define KG 243
#ifdef K
#undef K
#endif
#define K 243
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void conv1_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out, __global const Dtype* __restrict bias) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
__global const Dtype* Dptr = bias;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
Dtype biasval = Dptr[globalRow];
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN] + biasval;
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer ELU1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer bn1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] conv2 -> conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 8388608
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 4194304
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 512
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 256
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 512
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 256
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 262144
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 65536
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 4
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 4
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 2
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 2
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 32
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 64
#ifdef MG
#undef MG
#endif
#define MG 64
#ifdef M
#undef M
#endif
#define M 64
#ifdef N
#undef N
#endif
#define N 65536
#ifdef KG
#undef KG
#endif
#define KG 512
#ifdef K
#undef K
#endif
#define K 512
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void conv2_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out, __global const Dtype* __restrict bias) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
__global const Dtype* Dptr = bias;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
Dtype biasval = Dptr[globalRow];
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN] + biasval;
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer ELU2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer bn2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer conv3
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] conv3 -> conv3
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 4194304
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 256
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 256
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 65536
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 4
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 4
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 2
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 2
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 64
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1024
#ifdef K
#undef K
#endif
#define K 1024
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void conv3_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out, __global const Dtype* __restrict bias) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
__global const Dtype* Dptr = bias;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
Dtype biasval = Dptr[globalRow];
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN] + biasval;
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer ELU3
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer bn3
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer scale3
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer scale3
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer conv3_scale3_0_split
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] conv3_scale3_0_split -> conv3_scale3_0_split_0
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] conv3_scale3_0_split -> conv3_scale3_0_split_1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res1_conv1 -> res1_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res1_conv1_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_bn1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_ReLU1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res1_conv2 -> res1_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res1_conv2_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_bn2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_elewise
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res1_elewise -> res1_output
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res1_output_res1_elewise_0_split
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res1_output_res1_elewise_0_split -> res1_output_res1_elewise_0_split_0
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res1_output_res1_elewise_0_split -> res1_output_res1_elewise_0_split_1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res2_conv1 -> res2_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res2_conv1_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_bn1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_ReLU1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res2_conv2 -> res2_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res2_conv2_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_bn2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_elewise
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res2_elewise -> res2_output
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res2_output_res2_elewise_0_split
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res2_output_res2_elewise_0_split -> res2_output_res2_elewise_0_split_0
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res2_output_res2_elewise_0_split -> res2_output_res2_elewise_0_split_1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res3_conv1 -> res3_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res3_conv1_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_bn1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_ReLU1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res3_conv2 -> res3_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res3_conv2_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_bn2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_elewise
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res3_elewise -> res3_output
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res3_output_res3_elewise_0_split
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res3_output_res3_elewise_0_split -> res3_output_res3_elewise_0_split_0
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res3_output_res3_elewise_0_split -> res3_output_res3_elewise_0_split_1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res4_conv1 -> res4_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res4_conv1_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_bn1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_ReLU1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res4_conv2 -> res4_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res4_conv2_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_bn2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_elewise
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res4_elewise -> res4_output
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res4_output_res4_elewise_0_split
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res4_output_res4_elewise_0_split -> res4_output_res4_elewise_0_split_0
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res4_output_res4_elewise_0_split -> res4_output_res4_elewise_0_split_1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res5_conv1 -> res5_conv1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res5_conv1_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_bn1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_ReLU1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res5_conv2 -> res5_conv2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 2097152
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 128
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 128
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 16384
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 3
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 3
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 1
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 1
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 128
#ifdef MG
#undef MG
#endif
#define MG 128
#ifdef M
#undef M
#endif
#define M 128
#ifdef N
#undef N
#endif
#define N 16384
#ifdef KG
#undef KG
#endif
#define KG 1152
#ifdef K
#undef K
#endif
#define K 1152
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(RTSN, RTSM, 1)))
void res5_conv2_forward(__global const Dtype* __restrict im_in, __global const Dtype* __restrict wg, __global Dtype* __restrict im_out) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[TSM][TSK + v_pad_A];
volatile __local Dtype Bsub[TSK][TSN + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_in + v_B_off * batch;
__global Dtype* Cptr = im_out + v_C_off * batch;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
#pragma unroll 4
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[(offM + row) * K + tiledIndex];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) * v_s_1 - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) * v_s_0 - v_p_0;
imageIndex = imageIndex / v_imso_0;
bool in_range = true;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN];
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_bn2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer res5_elewise
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] res5_elewise -> res5_output
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] deconv5_1 -> deconv5_1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_A_off
#undef v_A_off
#endif
#define v_A_off 131072
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 2097152
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 4194304
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 128
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 256
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 128
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 256
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 16384
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 65536
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 4
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 4
#ifdef v_ks
#undef v_ks
#endif
#define v_ks 16
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 2
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 2
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 2
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 2
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 128
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 64
#ifdef MG
#undef MG
#endif
#define MG 64
#ifdef M
#undef M
#endif
#define M 64
#ifdef N
#undef N
#endif
#define N 65536
#ifdef KG
#undef KG
#endif
#define KG 2048
#ifdef K
#undef K
#endif
#define K 2048
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(8, 8, 1)))
__attribute__((vec_type_hint(Dtype4)))
void deconv5_1_forward(__global const Dtype* __restrict im_out, __global const Dtype* __restrict wg, __global Dtype* __restrict im_in, __global const Dtype* __restrict bias) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[32][8 + v_pad_A];
volatile __local Dtype Bsub[8][32 + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_out + v_B_off * batch;
__global Dtype* Cptr = im_in + v_C_off * batch;
__global const Dtype* Dptr = bias;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
int kidx = (v_ks - 1 - tiledIndex % v_ks) + (offM + row) * v_ks;
int midx = tiledIndex / v_ks;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[kidx + (v_fout / v_g * v_ks) * midx];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
bool in_range = true;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) - v_p_0;
imageIndex = imageIndex / v_imso_0;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im / v_s_0;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0 * v_s_0 && d_iter_im % v_s_0 == 0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im / v_s_1;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1 * v_s_1 && d_iter_im % v_s_1 == 0;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
Dtype biasval = Dptr[globalRow];
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN] + biasval;
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_1_ELU
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_1_bn
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_1_bn_sc
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_1_bn_sc
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] deconv5_2 -> deconv5_2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_A_off
#undef v_A_off
#endif
#define v_A_off 32768
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 4194304
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 8388608
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 256
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 512
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 256
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 512
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 65536
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 262144
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 4
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 4
#ifdef v_ks
#undef v_ks
#endif
#define v_ks 16
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 2
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 2
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 2
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 2
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 64
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 32
#ifdef MG
#undef MG
#endif
#define MG 32
#ifdef M
#undef M
#endif
#define M 32
#ifdef N
#undef N
#endif
#define N 262144
#ifdef KG
#undef KG
#endif
#define KG 1024
#ifdef K
#undef K
#endif
#define K 1024
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(8, 8, 1)))
__attribute__((vec_type_hint(Dtype4)))
void deconv5_2_forward(__global const Dtype* __restrict im_out, __global const Dtype* __restrict wg, __global Dtype* __restrict im_in, __global const Dtype* __restrict bias) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[32][8 + v_pad_A];
volatile __local Dtype Bsub[8][32 + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_out + v_B_off * batch;
__global Dtype* Cptr = im_in + v_C_off * batch;
__global const Dtype* Dptr = bias;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
int kidx = (v_ks - 1 - tiledIndex % v_ks) + (offM + row) * v_ks;
int midx = tiledIndex / v_ks;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[kidx + (v_fout / v_g * v_ks) * midx];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
bool in_range = true;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) - v_p_0;
imageIndex = imageIndex / v_imso_0;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im / v_s_0;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0 * v_s_0 && d_iter_im % v_s_0 == 0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im / v_s_1;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1 * v_s_1 && d_iter_im % v_s_1 == 0;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
Dtype biasval = Dptr[globalRow];
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN] + biasval;
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_2_ELU
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_2_bn
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_2_bn_sc
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_2_bn_sc
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer deconv5_3
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:408] deconv5_3 -> deconv5_3
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/base_conv_layer.cpp:481] #define Dtype float
#define Dtype1 float
#define Dtype2 float2
#define Dtype4 float4
#define Dtype8 float8
#define Dtype16 float16
#define VEC_1_0(X) X
#define VEC_2_0(X) X.x
#define VEC_2_1(X) X.y
#define VEC_4_0(X) X.x
#define VEC_4_1(X) X.y
#define VEC_4_2(X) X.z
#define VEC_4_3(X) X.w
#define VEC_8_0(X) X.s0
#define VEC_8_1(X) X.s1
#define VEC_8_2(X) X.s2
#define VEC_8_3(X) X.s3
#define VEC_8_4(X) X.s4
#define VEC_8_5(X) X.s5
#define VEC_8_6(X) X.s6
#define VEC_8_7(X) X.s7
#define VEC_16_0(X) X.s0
#define VEC_16_1(X) X.s1
#define VEC_16_2(X) X.s2
#define VEC_16_3(X) X.s3
#define VEC_16_4(X) X.s4
#define VEC_16_5(X) X.s5
#define VEC_16_6(X) X.s6
#define VEC_16_7(X) X.s7
#define VEC_16_8(X) X.s8
#define VEC_16_9(X) X.s9
#define VEC_16_10(X) X.sA
#define VEC_16_11(X) X.sB
#define VEC_16_12(X) X.sC
#define VEC_16_13(X) X.sD
#define VEC_16_14(X) X.sE
#define VEC_16_15(X) X.sF
#ifdef v_g
#undef v_g
#endif
#define v_g 1
#ifdef v_A_off
#undef v_A_off
#endif
#define v_A_off 7776
#ifdef v_B_off
#undef v_B_off
#endif
#define v_B_off 8388608
#ifdef v_C_off
#undef v_C_off
#endif
#define v_C_off 786432
#ifdef v_imsi_0
#undef v_imsi_0
#endif
#define v_imsi_0 512
#ifdef v_imso_0
#undef v_imso_0
#endif
#define v_imso_0 512
#ifdef v_imsi_1
#undef v_imsi_1
#endif
#define v_imsi_1 512
#ifdef v_imso_1
#undef v_imso_1
#endif
#define v_imso_1 512
#ifdef v_imsi
#undef v_imsi
#endif
#define v_imsi 262144
#ifdef v_imso
#undef v_imso
#endif
#define v_imso 262144
#ifdef v_k_0
#undef v_k_0
#endif
#define v_k_0 9
#ifdef v_k_1
#undef v_k_1
#endif
#define v_k_1 9
#ifdef v_ks
#undef v_ks
#endif
#define v_ks 81
#ifdef v_p_0
#undef v_p_0
#endif
#define v_p_0 4
#ifdef v_p_1
#undef v_p_1
#endif
#define v_p_1 4
#ifdef v_s_0
#undef v_s_0
#endif
#define v_s_0 1
#ifdef v_s_1
#undef v_s_1
#endif
#define v_s_1 1
#ifdef v_d_0
#undef v_d_0
#endif
#define v_d_0 1
#ifdef v_d_1
#undef v_d_1
#endif
#define v_d_1 1
#ifdef v_fin
#undef v_fin
#endif
#define v_fin 32
#ifdef v_fout
#undef v_fout
#endif
#define v_fout 3
#ifdef MG
#undef MG
#endif
#define MG 3
#ifdef M
#undef M
#endif
#define M 3
#ifdef N
#undef N
#endif
#define N 262144
#ifdef KG
#undef KG
#endif
#define KG 2592
#ifdef K
#undef K
#endif
#define K 2592
#ifdef v_pad_A
#undef v_pad_A
#endif
#define v_pad_A 1
#ifdef v_pad_B
#undef v_pad_B
#endif
#define v_pad_B 1
#ifdef TSM
#undef TSM
#endif
#define TSM 32
#ifdef TSN
#undef TSN
#endif
#define TSN 32
#ifdef TSK
#undef TSK
#endif
#define TSK 8
#ifdef TSK_UNROLL
#undef TSK_UNROLL
#endif
#define TSK_UNROLL 1
#ifdef WPTM
#undef WPTM
#endif
#define WPTM 4
#ifdef VWM
#undef VWM
#endif
#define VWM 4
#ifdef WPTN
#undef WPTN
#endif
#define WPTN 4
#ifdef VWN
#undef VWN
#endif
#define VWN 4
#ifdef RTSM
#undef RTSM
#endif
#define RTSM 8
#ifdef RTSN
#undef RTSN
#endif
#define RTSN 8
#ifdef LPTA
#undef LPTA
#endif
#define LPTA ((TSK*TSM)/(RTSM*RTSN))
#ifdef LPTB
#undef LPTB
#endif
#define LPTB ((TSK*TSN)/(RTSM*RTSN))
#ifdef v_num_tiles
#undef v_num_tiles
#endif
#define v_num_tiles (((K - 1)/(TSK*2) + 1)*2)
__kernel
__attribute__((reqd_work_group_size(8, 8, 1)))
__attribute__((vec_type_hint(Dtype4)))
void deconv5_3_forward(__global const Dtype* __restrict im_out, __global const Dtype* __restrict wg, __global Dtype* __restrict im_in, __global const Dtype* __restrict bias) {
const int tidn = get_local_id(0);
const int tidm = get_local_id(1);
const int offN = TSN*get_group_id(0);
const int offM = TSM*get_group_id(1);
volatile __local Dtype Asub[32][8 + v_pad_A];
volatile __local Dtype Bsub[8][32 + v_pad_B];
int batch = get_global_id(2);
__global const Dtype* Aptr = wg;
__global const Dtype* Bptr = im_out + v_B_off * batch;
__global Dtype* Cptr = im_in + v_C_off * batch;
__global const Dtype* Dptr = bias;
{
Dtype4 Creg[WPTM][WPTN/VWN];
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm][wn]) = 0.0;
VEC_4_1(Creg[wm][wn]) = 0.0;
VEC_4_2(Creg[wm][wn]) = 0.0;
VEC_4_3(Creg[wm][wn]) = 0.0;
}
}
{
#pragma unroll 1
for (int t = 0; t < v_num_tiles; ++t) {
{
for (int la = 0; la < LPTA; ++la) {
int tid = tidm * RTSN + tidn;
int id = la * RTSN * RTSM + tid;
int row = id / TSK;
int col = id % TSK;
int tiledIndex = TSK * t + col;
int kidx = (v_ks - 1 - tiledIndex % v_ks) + (offM + row) * v_ks;
int midx = tiledIndex / v_ks;
if ((offM + row) < M && tiledIndex < K) {
Asub[row][col] = Aptr[kidx + (v_fout / v_g * v_ks) * midx];
} else {
Asub[row][col] = 0.0;
}
}
}
{
#pragma unroll 4
for (int lb = 0; lb < LPTB; ++lb) {
int tid = tidm * RTSN + tidn;
int id = lb * RTSN * RTSM + tid;
int col = id % TSN;
int row = id / TSN;
int tiledIndex = TSK * t + row;
if ((offN + col) < N && tiledIndex < K) {
int d_iter_0;
int d_temp_0;
int d_iter_1;
int d_temp_1;
bool in_range = true;
int imageIndex = offN + col;
d_iter_1 = (tiledIndex % v_k_1) * v_d_1;
tiledIndex = tiledIndex / v_k_1;
d_temp_1 = (imageIndex % v_imso_1) - v_p_1;
imageIndex = imageIndex / v_imso_1;
d_iter_0 = (tiledIndex % v_k_0) * v_d_0;
tiledIndex = tiledIndex / v_k_0;
d_temp_0 = (imageIndex % v_imso_0) - v_p_0;
imageIndex = imageIndex / v_imso_0;
int d_iter_im;
d_iter_im = d_temp_0 + d_iter_0;
tiledIndex = tiledIndex * v_imsi_0 + d_iter_im / v_s_0;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_0 * v_s_0 && d_iter_im % v_s_0 == 0;
d_iter_im = d_temp_1 + d_iter_1;
tiledIndex = tiledIndex * v_imsi_1 + d_iter_im / v_s_1;
in_range &= d_iter_im >= 0 && d_iter_im < v_imsi_1 * v_s_1 && d_iter_im % v_s_1 == 0;
if (in_range) {
Bsub[row][col] = Bptr[tiledIndex];
} else {
Bsub[row][col] = 0.0;
}
} else {
Bsub[row][col] = 0.0;
}
}
}
barrier(CLK_LOCAL_MEM_FENCE);
Dtype4 Areg;
Dtype4 Breg[WPTN/VWN];
#pragma unroll 1
for (int kt=0; kt<TSK; kt+=TSK_UNROLL) {
#pragma unroll 1
for (int ku=0; ku<TSK_UNROLL; ++ku) {
int k = kt + ku;
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
int col = tidn + wn*VWN*RTSN;
VEC_4_0(Breg[wn]) = Bsub[k][col + 0];
VEC_4_1(Breg[wn]) = Bsub[k][col + 8];
VEC_4_2(Breg[wn]) = Bsub[k][col + 16];
VEC_4_3(Breg[wn]) = Bsub[k][col + 24];
}
#pragma unroll
for (int wm=0; wm<WPTM/VWM; ++wm) {
int row = tidm + wm*VWM*RTSM;
VEC_4_0(Areg) = Asub[row + 0][k];
VEC_4_1(Areg) = Asub[row + 8][k];
VEC_4_2(Areg) = Asub[row + 16][k];
VEC_4_3(Areg) = Asub[row + 24][k];
#pragma unroll
for (int wn=0; wn<WPTN/VWN; ++wn) {
VEC_4_0(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_0(Breg[wn]);
VEC_4_0(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_0(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_1(Breg[wn]);
VEC_4_1(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_1(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_2(Breg[wn]);
VEC_4_2(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_2(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 0][wn]) += VEC_4_0(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 1][wn]) += VEC_4_1(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 2][wn]) += VEC_4_2(Areg) * VEC_4_3(Breg[wn]);
VEC_4_3(Creg[wm * VWM + 3][wn]) += VEC_4_3(Areg) * VEC_4_3(Breg[wn]);
}
}
}
}

barrier(CLK_LOCAL_MEM_FENCE);
}
}
#pragma unroll
for (int wm=0; wm<WPTM; ++wm) {
int globalRow = offM + tidm + wm * RTSM;
Dtype biasval = Dptr[globalRow];
#pragma unroll
for (int wn=0; wn<WPTN; ++wn) {
int globalCol = offN + tidn + wn * RTSN;
if (globalRow < M && globalCol < N) {
Cptr[globalRow * N + globalCol] = ((Dtype*)(&(Creg[wm][wn/VWN])))[wn%VWN] + biasval;
}
}
}
}
}

INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer tanh
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer image_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer image_scale1
INFO /home/zrji/android_caffe/caffe-android-opencl/include/caffe/layer_factory.hpp:77] Creating layer image_scale2
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] image_scale2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] image_scale1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] tanh does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_3 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_2_bn_sc does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_2_bn does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_2_ELU does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_1_bn_sc does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_1_bn does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_1_ELU does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] deconv5_1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res5_elewise does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res5_scale2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res5_bn2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res5_conv2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res5_ReLU1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res5_scale1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res5_bn1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res5_conv1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_output_res4_elewise_0_split does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_elewise does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_scale2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_bn2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_conv2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_ReLU1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_scale1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_bn1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res4_conv1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_output_res3_elewise_0_split does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_elewise does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_scale2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_bn2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_conv2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_ReLU1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_scale1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_bn1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res3_conv1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_output_res2_elewise_0_split does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_elewise does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_scale2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_bn2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_conv2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_ReLU1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_scale1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_bn1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res2_conv1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_output_res1_elewise_0_split does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_elewise does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_scale2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_bn2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_conv2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_ReLU1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_scale1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_bn1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] res1_conv1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] conv3_scale3_0_split does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] scale3 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] bn3 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] ELU3 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] conv3 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] scale2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] bn2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] ELU2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] conv2 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] scale1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] bn1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] ELU1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] conv1 does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:228] data does not need backward computation.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/util/upgrade_proto.cpp:77] Attempting to upgrade batch norm layers using deprecated params: ./examples/style_transfer/a1.caffemodel
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/util/upgrade_proto.cpp:80] Successfully upgraded batch norm layers using deprecated params.
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:958] Ignoring source layer input
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Input layer: 0 with time: 2.8672e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 32 and 262144 and 243
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 1 with time: 0.00321933 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ELU layer: 2 with time: 0.000190176 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 3 with time: 0.0137734 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 4 with time: 0.000265984 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 64 and 65536 and 512
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 5 with time: 0.00232477 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ELU layer: 6 with time: 0.000104192 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 7 with time: 0.00102906 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 8 with time: 0.00016384 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1024
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 9 with time: 0.00237363 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ELU layer: 10 with time: 6.2656e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 11 with time: 0.00092128 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 12 with time: 0.000111616 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Split layer: 13 with time: 1.6032e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 14 with time: 0.00273981 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 15 with time: 0.000944704 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 16 with time: 0.000110592 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ReLU layer: 17 with time: 6.9664e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 18 with time: 0.00257926 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 19 with time: 0.000935488 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 20 with time: 0.000111648 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Eltwise layer: 21 with time: 0.000374848 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Split layer: 22 with time: 1.5872e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 23 with time: 0.0025641 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 24 with time: 0.000943904 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 25 with time: 0.000115104 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ReLU layer: 26 with time: 6.9504e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 27 with time: 0.00273632 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 28 with time: 0.000954208 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 29 with time: 0.000115968 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Eltwise layer: 30 with time: 0.000377792 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Split layer: 31 with time: 1.5168e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 32 with time: 0.00256595 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 33 with time: 0.00098128 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 34 with time: 0.00011664 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ReLU layer: 35 with time: 6.0384e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 36 with time: 0.00257382 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 37 with time: 0.000932032 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 38 with time: 0.000126464 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Eltwise layer: 39 with time: 0.000396768 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Split layer: 40 with time: 1.456e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 41 with time: 0.00273677 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 42 with time: 0.000980992 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 43 with time: 0.000116832 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ReLU layer: 44 with time: 6.1792e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 45 with time: 0.00256618 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 46 with time: 0.00106906 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 47 with time: 0.000120064 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Eltwise layer: 48 with time: 0.000401184 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Split layer: 49 with time: 1.536e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 50 with time: 0.00257229 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 51 with time: 0.000962272 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 52 with time: 0.00011888 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ReLU layer: 53 with time: 6.1056e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/conv_layer.cpp:123] The size of conv are 128 and 16384 and 1152
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Convolution layer: 54 with time: 0.00275894 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 55 with time: 0.000968704 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 56 with time: 0.00011904 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Eltwise layer: 57 with time: 0.000380064 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/deconv_layer.cpp:131] The size of deconv are 64 and 65536 and 2048
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Deconvolution layer: 58 with time: 0.00699754 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ELU layer: 59 with time: 0.000103488 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 60 with time: 0.00106134 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 61 with time: 0.000167648 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/deconv_layer.cpp:131] The size of deconv are 32 and 262144 and 1024
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Deconvolution layer: 62 with time: 0.00700461 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish ELU layer: 63 with time: 0.000188032 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish BatchNorm layer: 64 with time: 0.00174278 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 65 with time: 0.000255584 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/layers/deconv_layer.cpp:131] The size of deconv are 3 and 262144 and 2592
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Deconvolution layer: 66 with time: 0.0165403 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish TanH layer: 67 with time: 3.4624e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 68 with time: 9.0944e-05 seconds
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/net.cpp:612] Finish Scale layer: 69 with time: 6.3808e-05 seconds
The time used is 101178
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:298]   CL_DEVICE_NAME: GeForce RTX 2080
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:302]   CL_DEVICE_VENDOR: NVIDIA Corporation
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:306]   CL_DRIVER_VERSION: 410.73
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:314]   CL_DEVICE_TYPE:CL_DEVICE_TYPE_GPU
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:323]   CL_DEVICE_MAX_COMPUTE_UNITS: 46
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:328]   CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: 3
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:333]   CL_DEVICE_MAX_WORK_ITEM_SIZES:1024102464
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:338]   CL_DEVICE_MAX_WORK_GROUP_SIZE: 1024
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:343]   CL_DEVICE_MAX_CLOCK_FREQUENCY:1800 MHz
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:348]   CL_DEVICE_ADDRESS_BITS:64
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:353]   CL_DEVICE_MAX_MEM_ALLOC_SIZE:1988MByte
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:358]   CL_DEVICE_GLOBAL_MEM_SIZE:7952MByte
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:365]   CL_DEVICE_LOCAL_MEM_TYPE: local
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:372]   CL_DEVICE_LOCAL_MEM_SIZE:48KByte

INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:376]   CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE:64KByte

INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:382]   CL_DEVICE_QUEUE_PROPERTIES:CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:384]   CL_DEVICE_QUEUE_PROPERTIES:CL_QUEUE_PROFILING_ENABLE
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:389]   CL_DEVICE_IMAGE_SUPPORT:1
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:394]   CL_DEVICE_MAX_READ_IMAGE_ARGS:256
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:399]   CL_DEVICE_MAX_WRITE_IMAGE_ARGS:32
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:403] 
  CL_DEVICE_IMAGE <dim>
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:405] 2D_MAX_WIDTH32768
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:407] 2D_MAX_HEIGHT32768
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:409] 3D_MAX_WIDTH16384
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:411] 3D_MAX_HEIGHT16384
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:413] 3D_MAX_DEPTH16384
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:416]   CL_DEVICE_PREFERRED_VECTOR_WIDTH_<t>
INFO /home/zrji/android_caffe/caffe-android-opencl/src/caffe/common.cpp:424] CHAR1SHORT1INT1FLOAT1DOUBLE1
